document.addEventListener('DOMContentLoaded', async () => {
    const audioPlayer = document.getElementById('audio-player');
    const songsList = document.querySelector('.songs');
    const playButton = document.querySelector('.play-button');
    const nextButton = document.querySelector('.next-button');
    const prevButton = document.querySelector('.prev-button');
    const repeatButton = document.querySelector('.repeat-button');
    const shuffleButton = document.querySelector('.shuffle-button');

    // "Now Playing" UI elements
    const currentSongTitle = document.querySelector('.current-song');
    const currentArtist = document.querySelector('.current-artist');
    const currentAlbum = document.querySelector('.current-album');
    const albumArt = document.querySelector('.album-art');
    const progressBar = document.querySelector('.progress-bar');
    const currentTimeEl = document.querySelector('.current-time');
    const totalDurationEl = document.querySelector('.total-duration');

    const volumeSlider = document.querySelector('.volume-slider');
    const currentVolume = document.querySelector('.current-volume');
    const shufflePlayButton = document.querySelector('.shuffle');
    const sortOptions = document.querySelector('.sort-options');
    const muteButton = document.querySelector('.mute-button');
    const muteButtonIcon = muteButton.querySelector('img');
    const themeToggle = document.getElementById('theme-toggle');
    const searchBar = document.querySelector('.search-bar');
    const body = document.body;
    const themeIcon = document.querySelector('.theme-switch-container img');

    // --- Local Song Data ---
    // NOTE: The 'localSongs' array is now loaded from playlist.js,
    // which is generated by the Python script 'generate_playlist.py'.
    // Run the python script to update your playlist.

    // --- Server Health Check ---
    // This check ensures the Python server is running, which is required to serve audio files.
    try {
        const response = await fetch('/api/health');
        if (!response.ok) throw new Error('Server not responding');
        const data = await response.json();
        if (data.status !== 'ok') throw new Error('Server status not ok');
        console.log('Python server connection successful.');
    } catch (error) {
        console.error('Could not connect to the Python backend server.', error);
        document.body.innerHTML = `
            <div style="font-family: sans-serif; padding: 2rem; text-align: center; background: #fff1f1; border: 1px solid #ffbaba; color: #d8000c; margin: 1rem; border-radius: 8px;">
                <h1>Connection Error</h1>
                <p>The player could not connect to the required Python server.</p>
                <p>Please make sure you are running the <code>generate_playlist.py</code> script in your terminal, and then access the player by visiting <a href="http://127.0.0.1:5000">http://127.0.0.1:5000</a> in your browser.</p>
                <p><strong>Do not open the <code>index.html</code> file directly.</strong></p>
            </div>
        `;
        return; // Stop executing the rest of the script
    }

    // A mutable array to hold the currently displayed/sorted/shuffled tracks
    let currentTracks = [...localSongs];
    let currentIndex = -1;
    let isShuffled = false;
    let repeatMode = 'none'; // 'none', 'all', 'one'

    // Helper function to format time from seconds to M:SS
    const formatTime = (seconds) => {
        const minutes = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${minutes}:${secs < 10 ? '0' : ''}${secs}`;
    };

    // Function to render the list of songs
    const renderSongs = (tracks) => {
        songsList.innerHTML = ''; // Clear loading message or old songs
        tracks.forEach(track => {
            const songElement = document.createElement('li');
            songElement.className = 'song';
            // Store all necessary data in the element's dataset
            songElement.dataset.src = track.src;
            songElement.dataset.title = track.title;
            songElement.dataset.artist = track.artist;
            songElement.dataset.album = track.album;
            songElement.dataset.image = track.image;

            songElement.innerHTML = `
                <div class="song-info">
                    <div class="song-title">${track.title}</div>
                    <div class="song-artist">${track.artist}</div>
                    <div class="album-name">${track.album}</div>
                    <div class="song-duration">${track.duration}</div>
                </div>
            `;
            songsList.appendChild(songElement);
        });
    };

    // --- Player Logic ---

    // Core function to play a song by its index in the currentTracks array
    const playSongByIndex = (index) => {
        if (index < 0 || index >= currentTracks.length) {
            // Stop player if we go out of bounds and not repeating
            audioPlayer.pause();
            audioPlayer.src = '';
            playButton.classList.remove('playing');
            currentSongTitle.textContent = 'Select a song';
            currentArtist.textContent = '';
            currentAlbum.textContent = '';
            albumArt.src = 'assets/icons/music-player-svgrepo-com (1).svg'; // Default image
            progressBar.value = 0;
            currentTimeEl.textContent = '0:00';
            const playingSong = document.querySelector('.song.playing');
            if (playingSong) playingSong.classList.remove('playing');
            currentIndex = -1;
            return;
        }

        currentIndex = index;
        const track = currentTracks[index];

        // Update the "Now Playing" bar
        currentSongTitle.textContent = track.title;
        currentArtist.textContent = track.artist;
        currentAlbum.textContent = track.album;
        if (track.image) {
            albumArt.src = track.image;
            albumArt.style.visibility = 'visible';
        } else {
            albumArt.src = ''; // Use empty src for blank state
            albumArt.style.visibility = 'hidden'; // Hide broken icon, but keep space
        }
        totalDurationEl.textContent = track.duration;

        // Set max value of progress bar when song is loaded
        audioPlayer.addEventListener('loadedmetadata', () => { progressBar.max = audioPlayer.duration; });

        // Update audio source and play
        audioPlayer.src = track.src;
        audioPlayer.play();
        playButton.classList.add('playing');

        // Update the 'playing' style in the list
        const allSongElements = songsList.querySelectorAll('.song');
        allSongElements.forEach((el, i) => {
            el.classList.toggle('playing', i === currentIndex);
        });
    };

    // Helper to play a song when its element is clicked
    const playSongFromElement = (songElement) => {
        const songElements = Array.from(songsList.querySelectorAll('.song'));
        const index = songElements.indexOf(songElement);
        if (index !== -1) {
            playSongByIndex(index);
        }
    };

    // --- Play/Pause Logic ---

    // Function to toggle play/pause
    const togglePlay = () => {
        if (audioPlayer.paused && audioPlayer.src) {
            audioPlayer.play();
            playButton.classList.add('playing');
        } else {
            audioPlayer.pause();
            playButton.classList.remove('playing');
        }
    };

    // Listen for clicks on the main play button
    playButton.addEventListener('click', togglePlay);

    const playNext = () => {
        if (isShuffled) {
            let nextIndex;
            if (currentTracks.length > 1) {
                do {
                    nextIndex = Math.floor(Math.random() * currentTracks.length);
                } while (nextIndex === currentIndex);
            } else {
                nextIndex = 0;
            }
            playSongByIndex(nextIndex);
        } else {
            let nextIndex = currentIndex + 1;
            if (nextIndex >= currentTracks.length) {
                if (repeatMode === 'all') {
                    nextIndex = 0; // Wrap around
                } else {
                    nextIndex = -1; // End of playlist
                }
            }
            playSongByIndex(nextIndex);
        }
    };

    const playPrevious = () => {
        // In shuffle mode, "previous" just goes to the previous track in the shuffled list order.
        let prevIndex = currentIndex - 1;
        if (prevIndex < 0) {
            // If at the start, wrap to the end if repeating, otherwise stop.
            prevIndex = (repeatMode === 'all') ? currentTracks.length - 1 : -1;
        }
        playSongByIndex(prevIndex);
    };

    nextButton.addEventListener('click', playNext);
    prevButton.addEventListener('click', playPrevious);

    audioPlayer.addEventListener('ended', () => {
        if (repeatMode === 'one') {
            audioPlayer.currentTime = 0;
            audioPlayer.play();
        } else {
            playNext();
        }
    });

    // When a song fails to load, show an error message
    audioPlayer.addEventListener('error', () => {
        console.error("Error loading audio:", audioPlayer.error);
        currentSongTitle.textContent = "Error: Could not load song";
        currentArtist.textContent = `Check file path: ${audioPlayer.currentSrc.split('/').pop()}`;
        currentAlbum.textContent = "";
        playButton.classList.remove('playing');
    });

    // --- Progress Bar Logic ---
    audioPlayer.addEventListener('timeupdate', () => {
        // Update the slider's position
        progressBar.value = audioPlayer.currentTime;
        // Update the current time text
        currentTimeEl.textContent = formatTime(audioPlayer.currentTime);
    });

    // Allow seeking by dragging the progress bar
    progressBar.addEventListener('input', () => {
        audioPlayer.currentTime = progressBar.value;
    });


    // Use event delegation to listen for clicks on song items
    songsList.addEventListener('click', (event) => {
        const songElement = event.target.closest('.song');
        if (songElement) {
            playSongFromElement(songElement);
        }
    });

    // --- Search Logic ---
    searchBar.addEventListener('input', () => {
        const searchTerm = searchBar.value.toLowerCase();

        // We filter from the original, complete list of songs
        const filteredTracks = localSongs.filter(track => {
            const title = (track.title || '').toLowerCase();
            const artist = (track.artist || '').toLowerCase();
            const album = (track.album || '').toLowerCase();
            return title.includes(searchTerm) || artist.includes(searchTerm) || album.includes(searchTerm);
        });

        // Update the array that the player and list use
        currentTracks = filteredTracks;
        // Re-render the song list with the filtered results
        renderSongs(currentTracks);
    });

    // --- Shuffle and Sort Logic ---

    // Function to sort tracks and re-render the list
    const sortAndRender = (criteria) => {
        const durationToSeconds = (durationStr) => {
            if (!durationStr || !durationStr.includes(':')) return 0;
            const [minutes, seconds] = durationStr.split(':').map(Number);
            return (minutes * 60) + seconds;
        };

        currentTracks.sort((a, b) => {
            if (criteria === 'duration') {
                return durationToSeconds(a.duration) - durationToSeconds(b.duration);
            }
            // Handles title, artist, album with case-insensitive sorting
            const valA = a[criteria] || '';
            const valB = b[criteria] || '';
            return valA.localeCompare(valB, undefined, { sensitivity: 'base' });
        });

        renderSongs(currentTracks);
    };

    // Listen for clicks on the sort options
    sortOptions.addEventListener('click', (e) => {
        if (e.target.tagName === 'LI') {
            const criteria = e.target.textContent.toLowerCase();
            sortAndRender(criteria);
        }
    });

    // Listen for clicks on the "Shuffle and Play" button
    shufflePlayButton.addEventListener('click', () => {
        // Fisher-Yates shuffle algorithm
        for (let i = currentTracks.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [currentTracks[i], currentTracks[j]] = [currentTracks[j], currentTracks[i]];
        }
        // Re-render the list in the new shuffled order
        renderSongs(currentTracks);
        // Play the first song in the new shuffled list
        if (currentTracks.length > 0) {
            playSongByIndex(0);
        }
    });

    // --- Player Controls Logic ---

    shuffleButton.addEventListener('click', () => {
        isShuffled = !isShuffled;
        shuffleButton.classList.toggle('active', isShuffled);
    });

    repeatButton.addEventListener('click', () => {
        if (repeatMode === 'none') {
            repeatMode = 'all';
            repeatButton.classList.add('active');
        } else if (repeatMode === 'all') {
            repeatMode = 'one';
            // You could change the icon here for 'repeat-one' if you have one
        } else { // repeatMode is 'one'
            repeatMode = 'none';
            repeatButton.classList.remove('active');
        }
    });

    // --- Volume and Mute Logic ---

    // A function to update the mute icon based on volume/mute state
    const updateMuteIcon = () => {
        if (audioPlayer.muted || audioPlayer.volume === 0) {
            // NOTE: You'll need to add a 'volume-slash-svgrepo-com.svg' icon to your assets/icons folder
            muteButtonIcon.src = 'assets/icons/volume-slash-svgrepo-com.svg';
        } else {
            muteButtonIcon.src = 'assets/icons/volume-high-svgrepo-com.svg';
        }
    };

    // Function to sync the UI with the audio player's volume and mute state
    const updateVolumeUI = () => {
        // Sync slider value from audio state
        volumeSlider.value = audioPlayer.muted ? 0 : audioPlayer.volume * 100;

        const percentage = volumeSlider.value;

        // Update the slider's visual fill
        volumeSlider.style.background = `linear-gradient(to right, var(--battleship-gray) ${percentage}%, var(--french-gray) ${percentage}%)`;
        // Update the percentage text
        currentVolume.textContent = `${Math.round(percentage)}%`;

        // Update the mute icon
        updateMuteIcon();
    };

    // Listen for clicks on the mute button
    muteButton.addEventListener('click', () => {
        audioPlayer.muted = !audioPlayer.muted;
        updateVolumeUI();
    });

    // Listen for slider input to change volume
    volumeSlider.addEventListener('input', () => {
        audioPlayer.volume = volumeSlider.value / 100;
        // If user moves the slider, it should unmute
        audioPlayer.muted = false;
        updateVolumeUI();
    });

    // --- Theme Switcher Logic ---
    const applyTheme = (theme) => {
        if (theme === 'dark') {
            body.classList.add('dark-mode');
            themeToggle.checked = true;
            themeIcon.src = 'assets/icons/moon-svgrepo-com.svg';
        } else {
            body.classList.remove('dark-mode');
            themeToggle.checked = false;
            themeIcon.src = 'assets/icons/sun-svgrepo-com.svg';
        }
    };

    // Listen for toggle change
    themeToggle.addEventListener('change', () => {
        if (themeToggle.checked) {
            localStorage.setItem('theme', 'dark');
            applyTheme('dark');
        } else {
            localStorage.setItem('theme', 'light');
            applyTheme('light');
        }
    });

    // --- Background Art Fetching ---
    const fetchAndApplyAlbumArt = async () => {
        console.log("Starting background fetch for album art...");
        // Create a queue of promises to fetch art for songs that don't have it
        const artFetchPromises = localSongs.map((track, index) => {
            if (!track.image) {
                return (async () => {
                    try {
                        const artist = encodeURIComponent(track.artist);
                        const title = encodeURIComponent(track.title);
                        const response = await fetch(`/api/metadata?artist=${artist}&title=${title}`);
                        if (!response.ok) return;

                        const data = await response.json();
                        if (data.image) {
                            // Update the image in our master list
                            localSongs[index].image = data.image;

                            // If this is the currently playing song, update the UI now
                            if (currentIndex !== -1 && currentTracks[currentIndex].src === track.src) {
                                albumArt.src = data.image;
                                albumArt.style.visibility = 'visible';
                            }
                        }
                    } catch (e) {
                        // Fail silently, it's a background task
                    }
                })();
            }
        });
    };

    // Initial render of songs when the page loads
    renderSongs(currentTracks);
    // Set initial volume UI on load
    updateVolumeUI();
    // On initial load, check for saved theme
    applyTheme(localStorage.getItem('theme') || 'light'); // Default to light
    // Start fetching all album art in the background
    fetchAndApplyAlbumArt();
});