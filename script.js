document.addEventListener('DOMContentLoaded', () => {
    const audioPlayer = document.getElementById('audio-player');
    const songsList = document.querySelector('.songs');
    const playButton = document.querySelector('.play-button');

    // "Now Playing" UI elements
    const currentSongTitle = document.querySelector('.current-song');
    const currentArtist = document.querySelector('.current-artist');
    const currentAlbum = document.querySelector('.current-album');
    const albumArt = document.querySelector('.album-art');
    const volumeSlider = document.querySelector('.volume-slider');
    const currentVolume = document.querySelector('.current-volume');
    const shufflePlayButton = document.querySelector('.shuffle');
    const sortOptions = document.querySelector('.sort-options');
    const muteButton = document.querySelector('.mute-button');
    const muteButtonIcon = muteButton.querySelector('img');
    const themeToggle = document.getElementById('theme-toggle');
    const body = document.body;
    const themeIcon = document.querySelector('.theme-switch-container img');

    // --- Local Song Data ---
    // NOTE: The 'localSongs' array is now loaded from playlist.js,
    // which is generated by the Python script 'generate_playlist.py'.
    // Run the python script to update your playlist.

    // A mutable array to hold the currently displayed/sorted/shuffled tracks
    let currentTracks = [...localSongs];

    // Function to render the list of songs
    const renderSongs = (tracks) => {
        songsList.innerHTML = ''; // Clear loading message or old songs
        tracks.forEach(track => {
            const songElement = document.createElement('li');
            songElement.className = 'song';
            // Store all necessary data in the element's dataset
            songElement.dataset.src = track.src;
            songElement.dataset.title = track.title;
            songElement.dataset.artist = track.artist;
            songElement.dataset.album = track.album;
            songElement.dataset.image = track.image;

            songElement.innerHTML = `
                <div class="song-info">
                    <div class="song-title">${track.title}</div>
                    <div class="song-artist">${track.artist}</div>
                    <div class="album-name">${track.album}</div>
                    <div class="song-duration">${track.duration}</div>
                </div>
            `;
            songsList.appendChild(songElement);
        });
    };

    // --- Player Logic ---

    // Function to play a song and update the UI
    const playSong = (songElement) => {
        // Remove the 'playing' style from the previously playing song
        const currentlyPlayingSong = document.querySelector('.song.playing');
        if (currentlyPlayingSong) {
            currentlyPlayingSong.classList.remove('playing');
        }
        // Add the 'playing' style to the clicked song
        songElement.classList.add('playing');

        // Get data from the clicked song's dataset
        const { src, title, artist, album, image } = songElement.dataset;

        audioPlayer.src = src;
        audioPlayer.play();

        // Update the "Now Playing" bar
        currentSongTitle.textContent = title;
        currentArtist.textContent = artist;
        currentAlbum.textContent = album;
        albumArt.src = image;

        playButton.classList.add('playing');
    };

    // --- Play/Pause Logic ---

    // Function to toggle play/pause
    const togglePlay = () => {
        if (audioPlayer.paused && audioPlayer.src) {
            audioPlayer.play();
            playButton.classList.add('playing');
        } else {
            audioPlayer.pause();
            playButton.classList.remove('playing');
        }
    };

    // Listen for clicks on the main play button
    playButton.addEventListener('click', togglePlay);

    // When a song finishes, update the play button to show "play" again
    // When a song finishes, play the next one based on shuffle/repeat mode
    audioPlayer.addEventListener('ended', () => {
        playButton.classList.remove('playing');
    });

    // When a song fails to load, show an error message
    audioPlayer.addEventListener('error', () => {
        console.error("Error loading audio:", audioPlayer.error);
        currentSongTitle.textContent = "Error: Could not load song";
        currentArtist.textContent = `Check file path: ${audioPlayer.currentSrc.split('/').pop()}`;
        currentAlbum.textContent = "";
        playButton.classList.remove('playing');
    });

    // Use event delegation to listen for clicks on song items
    songsList.addEventListener('click', (event) => {
        const songElement = event.target.closest('.song');
        if (songElement) {
            playSong(songElement);
        }
    });

    // --- Shuffle and Sort Logic ---

    // Function to sort tracks and re-render the list
    const sortAndRender = (criteria) => {
        const durationToSeconds = (durationStr) => {
            if (!durationStr || !durationStr.includes(':')) return 0;
            const [minutes, seconds] = durationStr.split(':').map(Number);
            return (minutes * 60) + seconds;
        };

        currentTracks.sort((a, b) => {
            if (criteria === 'duration') {
                return durationToSeconds(a.duration) - durationToSeconds(b.duration);
            }
            // Handles title, artist, album with case-insensitive sorting
            const valA = a[criteria] || '';
            const valB = b[criteria] || '';
            return valA.localeCompare(valB, undefined, { sensitivity: 'base' });
        });

        renderSongs(currentTracks);
    };

    // Listen for clicks on the sort options
    sortOptions.addEventListener('click', (e) => {
        if (e.target.tagName === 'LI') {
            const criteria = e.target.textContent.toLowerCase();
            sortAndRender(criteria);
        }
    });

    // Listen for clicks on the "Shuffle and Play" button
    shufflePlayButton.addEventListener('click', () => {
        // Fisher-Yates shuffle algorithm
        for (let i = currentTracks.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [currentTracks[i], currentTracks[j]] = [currentTracks[j], currentTracks[i]];
        }
        // Re-render the list in the new shuffled order
        renderSongs(currentTracks);
        // Play the first song in the new shuffled list
        const firstSongElement = songsList.querySelector('.song');
        if (firstSongElement) {
            playSong(firstSongElement);
        }
    });
    
    // --- Volume and Mute Logic ---

    // A function to update the mute icon based on volume/mute state
    const updateMuteIcon = () => {
        if (audioPlayer.muted || audioPlayer.volume === 0) {
            // NOTE: You'll need to add a 'volume-slash-svgrepo-com.svg' icon to your assets/icons folder
            muteButtonIcon.src = 'assets/icons/volume-slash-svgrepo-com.svg';
        } else {
            muteButtonIcon.src = 'assets/icons/volume-high-svgrepo-com.svg';
        }
    };

    // Function to sync the UI with the audio player's volume and mute state
    const updateVolumeUI = () => {
        // Sync slider value from audio state
        volumeSlider.value = audioPlayer.muted ? 0 : audioPlayer.volume * 100;

        const percentage = volumeSlider.value;

        // Update the slider's visual fill
        volumeSlider.style.background = `linear-gradient(to right, var(--battleship-gray) ${percentage}%, var(--french-gray) ${percentage}%)`;
        // Update the percentage text
        currentVolume.textContent = `${Math.round(percentage)}%`;

        // Update the mute icon
        updateMuteIcon();
    };

    // Listen for clicks on the mute button
    muteButton.addEventListener('click', () => {
        audioPlayer.muted = !audioPlayer.muted;
        updateVolumeUI();
    });

    // Listen for slider input to change volume
    volumeSlider.addEventListener('input', () => {
        audioPlayer.volume = volumeSlider.value / 100;
        // If user moves the slider, it should unmute
        audioPlayer.muted = false;
        updateVolumeUI();
    });

    // --- Theme Switcher Logic ---
    const applyTheme = (theme) => {
        if (theme === 'dark') {
            body.classList.add('dark-mode');
            themeToggle.checked = true;
            themeIcon.src = 'assets/icons/moon-svgrepo-com.svg';
        } else {
            body.classList.remove('dark-mode');
            themeToggle.checked = false;
            themeIcon.src = 'assets/icons/sun-svgrepo-com.svg';
        }
    };

    // Listen for toggle change
    themeToggle.addEventListener('change', () => {
        if (themeToggle.checked) {
            localStorage.setItem('theme', 'dark');
            applyTheme('dark');
        } else {
            localStorage.setItem('theme', 'light');
            applyTheme('light');
        }
    });

    // Initial render of songs when the page loads
    renderSongs(currentTracks);
    // Set initial volume UI on load
    updateVolumeUI();
    // On initial load, check for saved theme
    applyTheme(localStorage.getItem('theme') || 'light'); // Default to light
});